#!/usr/bin/env python

import argparse

OPCODE_MASK = int("1111000000000000", 2)
RS_MASK     = int("0000110000000000", 2)
RT_MASK     = int("0000001100000000", 2)
RD_MASK     = int("0000000011000000", 2)
IMM_MASK    = int("0000000011111111", 2)

opcode_names = {
        0: "lw",
        1: "sw",
        2: "add",
        3: "addi",
        4: "inv", # note: does not take rs field
        5: "and",
        6: "andi",
        7: "or",
        8: "ori",
        9: "sra",
        10: "sll",
        11: "beq",
        12: "bne",
        13: "clr" # note: does not take rs field, rt and rd are the same
}

opcode_types = {
        0: "i",
        1: "i",
        2: "r",
        3: "i",
        4: "r",
        5: "r",
        6: "i",
        7: "r",
        8: "i",
        9: "i",
        10: "i",
        11: "j",
        12: "j",
        13: "r"
}


# gets the two's complement of an eight bit number
def twoscomp_8(val):
    if val & 0x80 == 0x80:
        return val - 0xFF - 1
    else:
        return val

# formats an eight bit number to hex or the two's complement representation in decimal
def format_value(val, decimal):
    if decimal:
        return str(twoscomp_8(val))
    else:
        return "0x{:02x}".format(val)

# formats an eight bit number to hex or decimal without two's complement conversion.
def format_addr(val, decimal):
    if decimal:
        return str(val)
    else:
        return "0x{:02x}".format(val)

# prints a string with the given address and indentation as requested
def prepend_address(address, string, show_addr, tab, decimal):
    out_string = ""
    if show_addr:
        out_string += "{0:3}: ".format(format_addr(address, decimal))
    if tab and string:
        out_string += 4*" "
    out_string += string
    print(out_string)

# prints a label, with a leading newline for separation
def print_label(address, show_addr, decimal):
    prepend_address(address, "", show_addr, False, decimal)
    prepend_address(address, "loc_{}:".format(format_addr(address, decimal)), show_addr, False, decimal)

# represents an Instruction of any valid type
class Instruction:
    # raw 16-bit number -> Instruction object
    def __init__(self, raw_instr, address):
        self.opcode = (raw_instr & OPCODE_MASK) >> 12

        # check for invalid opcode while initializing
        if not opcode_names.has_key(self.opcode):
            raise RuntimeError("machine instruction ", format(raw_instr, "x"), "not recognizable as r, i, or j type instruction")

        self.rs = (raw_instr & RS_MASK) >> 10
        self.rt = (raw_instr & RT_MASK) >> 8
        self.rd = (raw_instr & RD_MASK) >> 6
        self.imm = raw_instr & IMM_MASK
        self.name = opcode_names.get(self.opcode)
        self.type = opcode_types.get(self.opcode)
        self.address = address

    # add the offset from this instruction to the given address
    # should only be called on branch instructions
    def get_branch_dest(self):
        offset = twoscomp_8(self.imm)
        return self.address + offset

    # creates the string representing the instruction in assembly
    def to_string(self, decimal):
        # switch on instruction type, including special cases.
        if self.name == "lw" or self.name == "sw":
            return "{0} ${1}, {2}(${3})".format(self.name, self.rt, format_value(self.imm, decimal), self.rs)

        elif self.name == "inv":
            return "{0} ${1}, ${2}".format(self.name, self.rd, self.rt)

        elif self.name == "clr":
            return "{0} ${1}".format(self.name, self.rt)

        elif self.type == "i":
            return "{0} ${1}, ${2}, {3}".format(self.name, self.rt, self.rs, format_value(self.imm, decimal))

        elif self.type == "r":
            return "{0} ${1}, ${2}, ${3}".format(self.name, self.rd, self.rs, self.rt)

        elif self.type == "j":
            return "{0} ${1}, ${2}, loc_{3}".format(self.name, self.rs, self.rt, format_value(self.get_branch_dest(), decimal))


if __name__ == "__main__":
    # argument parsing
    parser = argparse.ArgumentParser(description="A disassembler for EECE2322 style machine code created with zassemble.c")
    parser.add_argument("file", help="the path to a machine_code.coe file generated by zassemble")
    parser.add_argument("--addresses", help="shows the address of every instruction, indexed at 0", action="store_true")
    parser.add_argument("--notab", help="do not indent anything. note: always set if no labels present", action="store_true")
    parser.add_argument("--dec", help="show all immediate values and addresses in decimal", action="store_true")
    args = parser.parse_args()

    # file processing
    with open(args.file, "r") as fd:
        first_line = fd.readline()
        if first_line != "memory_initialization_radix=16;\n":
            raise RuntimeError("File does not appear to be generated by zassemble.c:", first_line)
        comma_sep = fd.readline().strip("memory_initialization_vector=").strip(";\n")
        hex_strings = comma_sep.split(",")
        values = [int(i, 16) for i in hex_strings]


    # create a list of instructions
    instruction_list = []
    for address, raw_instr in enumerate(values):
        instruction_list.append(Instruction(raw_instr, address))

    # pre-process labels into a set for printing later
    labels = set([])
    for instr in instruction_list:
        if instr.type == "j":
            labels.add(instr.get_branch_dest())

    # ensure we do not indent if there are no labels
    if not labels:
        args.notab = True

    # print instructions and labels, if they exist
    for instr in instruction_list:

        # handle printing a label if it one exists at the current address
        if instr.address in labels:
            print_label(instr.address, args.addresses, args.dec)
            labels.remove(instr.address)

        # print the instruction with address / indenting as required
        prepend_address(instr.address, instr.to_string(args.dec), args.addresses, not args.notab, args.dec)

